#!/usr/bin/env bash

# Age encryption using secrets in 1password vault
# Date: 2023-05-29
# Version: 0.2
#
# Run `age-op -h` for help and examples
#
# For information about age, see https://github.com/FiloSottile/age
# Tested on mac and linux. Tested with age and rage (rust-rage)

# check dependencies
# Change to 'rage' if you prefer
AGE=${AGE:-$(which age)}
OP=${OP:-op}
prog=$(basename $0)

# Select private folder for temporary secrets. can be overridden with `-t` flag
# The defaults for linux and macos are readable by owner only
# Returns: temp folder path with no trailing '/'
private_tmp() {
  if [ -d /run/user/$(id -u) ]; then
    echo /run/user/$(id -u)      # linux. folder owned by user with mode 700
  elif [ -d "$TMPDIR" ]; then
    echo "$(echo $TMPDIR | sed 's./$..')"  # macos. owned by user with mode 700. remove trailing slash
  else
    echo "$PWD"
  fi
}
tmppath=$(private_tmp)


# Dislpay help message and quit
# param: ERROR_MESSAGE
# If ERROR_MESSAGE is not empty, exits 1, otherwise exits 0
_help() {
  [ -n "$1" ] && echo "Error: $1\n"
  local ds="\$"
  cat <<_HELP

age encryption with secret keys in 1password vault

Examples:

   Encrypt file:
       $prog -e -k KEY_PATH [ -o OUTPUT ] [ -t TMPDIR ] [ FILE ]
           encrypt a single input file FILE.
           If FILE is '-' or not specified, stdin is encrypted
           If OUTPUT is '-' or not specified, the output is sent to stdout

       To encrypt one or more files or folders to a tar file, use
           tar czf - FILE_OR_DIR FILE_OR_DIR ... | $prog -e -k KEY_PATH -o foo.tar.gz.age

   Decrypt file:
       $prog -d -k KEY_PATH [ -o OUTPUT ] [-t TMPDIR ] [ FILE ]
           decrypt a file, or stdin
           If FILE is '-' or not specified, stdin is decrypted
           If OUTPUT is '-' or not specified, the output is sent to stdout

       To decrypt a tar file,
           $prog -d -k KEY_PATH foo.tar.gz.age | tar xzf -

   Generate an age ed25519 key and store it in the 1password vault. The type of the new item will be "Password"
       $prog -n -k KEY_PATH

KEY_PATH should have one of the following formats:
    - 'op://vault/title', 'op://vault/title/field', or 'op://vault/title/section/field'
    In the first case, the field name defaults to 'password'

TMPDIR is the temporary folder where key will be briefly written and quickly removed
    Default is '$tmppath'

1Password configuration:
    For the 1Password cli ('op') to authenticate with a vault, you can do one of the following:
     - For use with a service account, set the environment variable OP_SERVICE_ACCOUNT_TOKEN
     - For use with a 1Password Connect Server, set OP_CONNECT_HOST and OP_CONNECT_TOKEN
     - sign into a local app with "eval ${ds}(op signin)"

Dependencies: Installation instructions and documentation:
  age: https://age-encryption.org
  op (1Password cli): https://developer.1password.com/docs/cli/get-started

_HELP
  [ -n "$1" ] && exit 1 || exit 0
}

# Store key in unique temp file, with access limited to current user
# params: TMPDIR KEY
# returns: path to temp file
store_secret() {
  secret=$(mktemp "$1/age-secret.XXXXXX")
  chmod 600 "$secret"
  cat >"$secret" <<_EKEY
$2
_EKEY
  echo "$secret"
}

# Create a new key
# params: KEYPATH
new_key() {
  local keypath="$1"
  local key field out pw title vault field

  ##
  ## Create new key
  ##
  vault=$(echo $keypath | sed -E 's|op://([^/]+)\/([^/]+)\/(.*)|\1|')
  title=$(echo $keypath | sed -E 's|op://([^/]+)\/([^/]+)\/(.*)|\2|')
  field=$(echo $keypath | sed -E 's|op://([^/]+)\/([^/]+)\/(.*)|\3|')

  # check if the key path exists so we don't overwrite it.
  # The successs case (key is unique) generates an error, so temporarily disable '+e'
  set +e
  key=$($OP item get "$title" "--vault=$vault" 2>/dev/null)
  [ $? -eq 0 ] && _help "Key vault:$vault  title:$title already exists - will not overwrite"
  set -e
  pw="$(age-keygen)"
  out=$($OP item create --category=password --title="$title" --vault="$vault" "$field=$pw")
  echo "Created vault:$vault  title:$title"
}

keypath=""
newkey=0
tmppath=$(private_tmp)
passthruargs=()

[ ! $($AGE --help 2>&1 |grep Usage) ] && _help "Missing 'age' dependency. Please see installation url below."
# 1password cli
[ ! $($OP --version) ] && _help "Missing 'op' dependency. Please see installation url below."

# no need to support getopts-style parameters (`-abc` instead of `-a -b -c`)
# since age itself doesn't (this greatly simplifies parameter parsing!)
while [[ $# -gt 0 ]]; do
  param="$1"
  shift
  case $param in
    -h | --help | help)
      _help
      ;;
    -n | --new)
      newkey=1
      ;;
    -k | --keypath)
      keypath=$1
      shift
      if [[ ! $keypath =~ ^op://[^/]+/[^/]+/.+$ ]]; then
        # if path has only two segments (vault & title), append field "password"
        # since the 'new' function creates items of type Password
        if [[ $keypath =~ ^op://[^/]+/[^/]+$ ]]; then
          keypath="$keypath/password"
        else
          _help "Invalid key path '$keypath'"
        fi
      fi
      ;;
    -t | --tmppath)
      tmppath=$1
      shift
      [ ! -d "$tmppath" ] && _help "Invalid tmp folder: '$tmppath' does not exist"
      ;;
    *)
      passthruargs+=("$param")
      ;;
  esac
done

# TODO: couldn't we use this new key for encrypt operations?
[ $newkey -eq 1 ] && [ -n "$tmppath$passthruargs" ] \
  && _help "-n/--new can only be used with -k/--keypath"
[ -z "$keypath" ]  && _help "keypath is required. Should be of the form op://vault/title[/field]"

if [ $newkey -eq 1 ]; then
  new_key $keypath
else
  key=$($OP read "$keypath")
  if [ $? -ne 0 ] || [ -z "$key" ]; then
    _help "Invalid keypath '$keypath'"
  fi
  secret=$(store_secret "$tmppath" "$key")

  ## try
  {(
    set +e # don't quit on error here - we want to make sure secret is deleted
    # if stdin is a terminal, then don't connect it to age
    if [ -t 0 ]; then
      $AGE -i "$secret" "${passthruargs[@]}" >&1
    else
      $AGE -i "$secret" "${passthruargs[@]}" <&0 >&1
    fi
  )}
  ## catch
  {
    rm -f "$secret"
  }
fi

unset  _err cmd input key keypath output secret stdin tmppath
